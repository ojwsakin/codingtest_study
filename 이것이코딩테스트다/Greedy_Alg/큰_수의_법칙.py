## '나동빈의 큰 수의 법칙'
## 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
## 단, 배열의 특정한 index에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 특징

## 첫째 줄에 N(2부터 1000), M(1부터 10000), K(1부터 10000)의 자연수 -> 공백으로 구분
## 둘째 줄에 N개의 자연수가 주어지고, 공백으로 구분 -> 1부터 10000
## K는 항상 M보다 작거나 같다

# N, M, K 입력
n, m, k = map(int, input().split())

# n -> 반복문에서 사용?
# M -> 덧셈 개수
# K -> K 번을 초과 할 수 없다

# 둘째 줄 데이터 입력 -> list 
n_list = list(map(int, input().split()))

# n_list 를 정렬
n_list.sort()

## 조건
## 제일 큰 수와 두번째로 큰 수만 있으면 해결된다

## 큰 수를 먼저 K번 진행 -> 두번째 큰 수를 한 번 -> 다시 큰 수를 진행

# 큰 수와 두번째 수를 설정
# 수가 같아도 index가 다르니 상관 없음 -> "조건 확인 잘하자"
max = n_list[-1]
max_sec = n_list[-2]

######### 내가 푼 방법 #########
# 계산 하기 
# 같은 인덱스가 3번 나오면 오답
# 두 수가 같으면 상관 없지만 다를 경우를 생각해야함
print(((k * max + max_sec) * (m // (k + 1))) + (max * (m % (k + 1))))





######### 단순하게 푸는 방법 - 그냥 참고만 #########
result = 0

while True:
    for i in range(k): # 가장 큰 수를 k번 더하기 
        if m == 0: # m이 0이면 탈출
            break
        result += max
        m -= 1 # m 에서 1씩 빼줌
    if m == 0:
        break  # m = 0이면 탈출
    result += max_sec # 두번째로 큰 수 한번 더해주기
    m -= 1